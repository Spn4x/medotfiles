===== src/app_dock.h =====
// src/app_dock.h

#ifndef APP_DOCK_H
#define APP_DOCK_H

#include <gtk/gtk.h>

GtkWidget* create_dock_view(GtkStack *stack);
// The signature must match the implementation in the .c file for use with g_timeout_add
gboolean update_running_apps(gpointer user_data);

#endif===== src/utils.h =====
#ifndef UTILS_H
#define UTILS_H

#include <gio/gio.h>

void execute_command_async(const char* command, GAsyncReadyCallback callback, gpointer user_data);

// Declare the new functions to get specific output streams
const char* get_command_stdout(GAsyncResult *res);
const char* get_command_stderr(GAsyncResult *res);

#endif===== src/popout_panels.c =====
#include <gtk4-layer-shell.h>
#include <adwaita.h>
#include "popout_panels.h"
#include "control_center.h"
#include "utils.h"
#include <glib/gregex.h>

#define MAIN_SIDEBAR_WIDTH 66

// --- Structs for this file ---
// This is the main state-tracking struct for the entire connection process.
typedef struct {
    gchar *ssid;
    gchar *password; // This will be NULL for the initial silent attempt.
    GtkWidget *list_box;
    AdwToastOverlay *toast_overlay;
    GtkWidget *parent_window; // So we know where to show the dialog if needed.
    int attempt_number;
} WifiAsyncData;

// A simple struct to pass data from the list to the click handler.
typedef struct {
    gchar *ssid;
    GtkWidget *list_box;
} WifiClickData;

typedef struct { guint id; gchar *name; } AudioSink;
typedef struct { GtkBox *list_box; gchar *active_ssid; } WifiUpdateData;
typedef struct { gchar *mac_address; GtkWidget *list_box; } BtActionData;


// --- Forward Declarations ---
static void try_next_wifi_step(WifiAsyncData *data);
static void on_wifi_command_finished(GObject *source, GAsyncResult *res, gpointer user_data);
static void free_wifi_click_data(gpointer data, GClosure *closure);
static void show_password_dialog(WifiAsyncData *data);
static void on_password_dialog_response(GObject *source, GAsyncResult *result, gpointer user_data);

static void on_initial_volume_ready(GObject *s, GAsyncResult *res, gpointer d);
static void on_volume_changed(GtkRange *r, gpointer d);
static void on_sinks_ready(GObject *s, GAsyncResult *res, gpointer d);
static void on_sink_selected(GtkDropDown *dd, GParamSpec *p, gpointer d);
static void on_sink_set_finished(GObject *s, GAsyncResult *res, gpointer d);
static void on_wifi_scan_ready(GObject *source_object, GAsyncResult *res, gpointer user_data);
static void on_wifi_connect_clicked(GtkButton *button, gpointer user_data);
static gboolean trigger_wifi_scan_refresh(gpointer user_data);
static void on_wifi_panel_destroy(GtkWidget *widget, gpointer user_data);
static void on_wifi_panel_state_set(GtkSwitch *sw, gboolean state, gpointer d);
static void on_wifi_panel_status_ready(GObject *s, GAsyncResult *res, gpointer d);
static void free_audio_sink(gpointer d);
static void free_bt_action_data(gpointer d, GClosure *closure);
static gboolean trigger_bt_refresh(gpointer user_data);
static void on_bt_list_needs_refresh(GObject *s, GAsyncResult *res, gpointer d);
static void on_bt_connect_clicked(GtkButton *button, gpointer user_data);
static void on_bt_disconnect_clicked(GtkButton *button, gpointer user_data);
static void on_bt_paired_devices_ready(GObject *s, GAsyncResult *res, gpointer d);
static void on_bt_connected_devices_ready(GObject *s, GAsyncResult *res, gpointer d);
static void on_bt_panel_state_set(GtkSwitch *sw, gboolean state, gpointer d);
static void on_bt_panel_status_ready(GObject *s, GAsyncResult *res, gpointer d);
static void on_bt_panel_destroy(GtkWidget *widget, gpointer user_data);


// --- Helper Functions ---
static void free_wifi_click_data(gpointer data, GClosure *closure) {
    (void)closure;
    WifiClickData *d = data;
    g_free(d->ssid);
    g_free(d);
}

// --- Audio Callbacks ---
static void on_sink_set_finished(GObject *s, GAsyncResult *res, gpointer d) {
    (void)s; (void)res;
    if (d)
        execute_command_async("wpctl get-volume @DEFAULT_SINK@", on_initial_volume_ready, ((ControlWidgets*)d)->volume_slider);
}
static void on_volume_changed(GtkRange *r, gpointer d) {
    (void)d;
    int v = (int)gtk_range_get_value(r);
    char cmd[64];
    snprintf(cmd, sizeof(cmd), "wpctl set-volume @DEFAULT_SINK@ %d%%", v);
    execute_command_async(cmd, NULL, NULL);
}
static void on_initial_volume_ready(GObject *s, GAsyncResult *res, gpointer d) {
    (void)s;
    GtkScale *vs = GTK_SCALE(d);
    const char *out = get_command_stdout(res);
    if (!out) return;
    if (strstr(out, "[MUTED]")) {
        gtk_range_set_value(GTK_RANGE(vs), 0);
        return;
    }
    const char *vol_s = strstr(out, "Volume: ");
    if (vol_s) {
        double v_f = atof(vol_s + 8);
        g_signal_handlers_block_by_func(vs, G_CALLBACK(on_volume_changed), NULL);
        gtk_range_set_value(GTK_RANGE(vs), v_f * 100);
        g_signal_handlers_unblock_by_func(vs, G_CALLBACK(on_volume_changed), NULL);
    }
}
static void free_audio_sink(gpointer data) {
    AudioSink *s = data;
    g_free(s->name);
    g_free(s);
}
static void on_sink_selected(GtkDropDown *dd, GParamSpec *p, gpointer d) {
    (void)p;
    ControlWidgets *w = d;
    GList *sinks = g_object_get_data(G_OBJECT(dd), "sinks-list");
    if (!sinks || !w) return;
    if (gtk_widget_get_realized(GTK_WIDGET(dd))) {
        guint idx = gtk_drop_down_get_selected(dd);
        AudioSink *sel = g_list_nth_data(sinks, idx);
        if (sel) {
            char cmd[64];
            snprintf(cmd, sizeof(cmd), "wpctl set-default %u", sel->id);
            execute_command_async(cmd, on_sink_set_finished, w);
        }
    }
}
static void on_sinks_ready(GObject *s, GAsyncResult *res, gpointer d) {
    (void)s;
    GtkDropDown *dd = GTK_DROP_DOWN(d);
    const char *o = get_command_stdout(res);
    if (!o) return;

    gchar *default_id_str = NULL;
    GRegex *default_regex = g_regex_new("Default Sink:\\s*(\\S+)", G_REGEX_MULTILINE, 0, NULL);
    if (default_regex) {
        GMatchInfo *mi = NULL;
        if (g_regex_match(default_regex, o, 0, &mi)) {
            default_id_str = g_match_info_fetch(mi, 1);
        }
        g_match_info_free(mi);
        g_regex_unref(default_regex);
    }

    GList *sinks = NULL;
    GtkStringList *model = gtk_string_list_new(NULL);
    
    GRegex *sinks_regex = g_regex_new("([0-9]+)\\.\\s*(.*?)\\[vol:", G_REGEX_MULTILINE, 0, NULL);
    if (sinks_regex) {
        GMatchInfo *mi = NULL;
        g_regex_match(sinks_regex, o, 0, &mi);
        while (g_match_info_matches(mi)) {
            gchar *id_str = g_match_info_fetch(mi, 1);
            gchar *raw_name = g_match_info_fetch(mi, 2);
            gchar *name = g_strstrip(g_strdup(raw_name));

            if (!g_str_has_prefix(name, "Easy Effects")) {
                AudioSink *sink = g_new0(AudioSink, 1);
                sink->id = (guint)atoi(id_str);
                sink->name = name;
                sinks = g_list_append(sinks, sink);
                gtk_string_list_append(model, sink->name);
            } else {
                g_free(name);
            }
            g_free(id_str);
            g_free(raw_name);
            g_match_info_next(mi, NULL);
        }
        g_match_info_free(mi);
        g_regex_unref(sinks_regex);
    }

    guint default_idx = 0;
    if (default_id_str) {
        guint i = 0;
        for (GList *l = sinks; l; l = l->next, i++) {
            if (strstr(default_id_str, g_strdup_printf(".%d", ((AudioSink*)l->data)->id))) {
                default_idx = i;
                break;
            }
        }
        g_free(default_id_str);
    }
    
    g_signal_handlers_block_by_func(dd, G_CALLBACK(on_sink_selected), NULL);
    gtk_drop_down_set_model(dd, G_LIST_MODEL(model));
    if (gtk_string_list_get_string(model, 0) != NULL) {
        gtk_drop_down_set_selected(dd, default_idx);
    }
    g_object_set_data_full(G_OBJECT(dd), "sinks-list", sinks, (GDestroyNotify)free_audio_sink);
    g_signal_handlers_unblock_by_func(dd, G_CALLBACK(on_sink_selected), NULL);
}


// --- Wi-Fi Callbacks ---

// The user clicks a network in the list. This is the new entry point.
static void on_wifi_connect_clicked(GtkButton *button, gpointer user_data) {
    WifiClickData *click_data = user_data;
    GtkWidget *win = gtk_widget_get_ancestor(GTK_WIDGET(button), GTK_TYPE_WINDOW);

    if (!win) {
        g_warning("Could not find parent window to start Wi-Fi connection.");
        return;
    }
    
    g_print("Starting silent connection attempt for SSID: %s\n", click_data->ssid);

    // Create the data structure that will live through the entire process.
    WifiAsyncData *async_data = g_new0(WifiAsyncData, 1);
    async_data->ssid = g_strdup(click_data->ssid);
    async_data->password = NULL; // We start with no password.
    async_data->list_box = click_data->list_box;
    async_data->toast_overlay = ADW_TOAST_OVERLAY(g_object_get_data(G_OBJECT(win), "toast-overlay"));
    async_data->parent_window = win;
    async_data->attempt_number = 0;
    
    // Start the silent connection state machine.
    try_next_wifi_step(async_data);
}

// The core state machine.
static void try_next_wifi_step(WifiAsyncData *data) {
    g_autoptr(GError) error = NULL;
    GSubprocess *process = NULL;
    // Fix: Moved process creation inside each case to avoid dangling pointers
    
    switch (data->attempt_number) {
        case 0: { // Attempt 0: Try to bring an existing connection 'up'.
            g_print("Wi-Fi Attempt 0: Trying 'nmcli connection up' for SSID '%s'\n", data->ssid);
            const gchar *argv[] = {"nmcli", "connection", "up", data->ssid, NULL};
            process = g_subprocess_newv(argv, G_SUBPROCESS_FLAGS_NONE, &error);
            break;
        }
        case 1: { // Attempt 1: Delete any potentially broken existing connection profile.
            g_print("Wi-Fi Attempt 1: Trying to delete existing profile for SSID '%s'\n", data->ssid);
            const gchar *argv[] = {"nmcli", "connection", "delete", data->ssid, NULL};
            process = g_subprocess_newv(argv, G_SUBPROCESS_FLAGS_NONE, &error);
            break;
        }
        case 2: { // Attempt 2: Add a new connection profile.
            g_print("Wi-Fi Attempt 2: Adding new connection profile for SSID '%s'\n", data->ssid);
            if (data->password && *data->password) {
                const gchar *argv[] = {
                    "nmcli", "connection", "add", "type", "wifi", 
                    "con-name", data->ssid, "ifname", "wlan0", "ssid", data->ssid,
                    "--",
                    "wifi-sec.key-mgmt", "wpa-psk", 
                    "wifi-sec.psk", data->password,
                    NULL
                };
                process = g_subprocess_newv(argv, G_SUBPROCESS_FLAGS_NONE, &error);
            } else {
                const gchar *argv[] = {
                    "nmcli", "connection", "add", "type", "wifi", 
                    "con-name", data->ssid, "ifname", "wlan0", "ssid", data->ssid,
                    NULL
                };
                process = g_subprocess_newv(argv, G_SUBPROCESS_FLAGS_NONE, &error);
            }
            break;
        }
        case 3: { // Attempt 3: Explicitly bring up the newly created profile.
            g_print("Wi-Fi Attempt 3: Bringing up new connection for SSID '%s'\n", data->ssid);
            const gchar *argv[] = {"nmcli", "connection", "up", data->ssid, NULL};
            process = g_subprocess_newv(argv, G_SUBPROCESS_FLAGS_NONE, &error);
            break;
        }
        default: // All silent/automated attempts have failed.
            if (data->password) {
                 g_warning("All Wi-Fi connection methods failed for SSID '%s', even with password.\n", data->ssid);
                 adw_toast_overlay_add_toast(data->toast_overlay, adw_toast_new("Connection failed. Incorrect password?"));
                 g_free(data->ssid);
                 g_free(data->password);
                 g_free(data);
            } else {
                g_print("Silent attempts failed. Prompting for password for SSID: %s\n", data->ssid);
                show_password_dialog(data);
            }
            return; // Stop the state machine for now.
    }

    if (error) {
        g_warning("Failed to spawn nmcli process: %s\n", error->message);
        data->attempt_number++;
        try_next_wifi_step(data);
        return;
    }
    g_subprocess_wait_check_async(process, NULL, (GAsyncReadyCallback)on_wifi_command_finished, data);
}


// This function is called after each command finishes.
static void on_wifi_command_finished(GObject *source, GAsyncResult *res, gpointer user_data) {
    WifiAsyncData *data = user_data;
    g_autoptr(GError) error = NULL;
    gboolean success = g_subprocess_wait_check_finish(G_SUBPROCESS(source), res, &error);

    if (success) {
        // Any successful 'up' is a final victory.
        if (data->attempt_number == 0 || data->attempt_number == 3) {
            g_print("Wi-Fi connection successful for SSID: %s\n", data->ssid);
            adw_toast_overlay_add_toast(data->toast_overlay, adw_toast_new_format("Connected to %s", data->ssid));
            trigger_wifi_scan_refresh(data->list_box);
            g_free(data->ssid);
            g_free(data->password);
            g_free(data);
            return;
        }
    }
    
    // Case 1: 'delete' (attempt 1) can fail, that's fine. Always proceed.
    // Case 2: 'add' (attempt 2) MUST succeed to continue.
    if (data->attempt_number == 1 || (data->attempt_number == 2 && success)) {
        data->attempt_number++;
        try_next_wifi_step(data);
        return;
    }
    
    if (!success) {
        g_warning("Wi-Fi attempt %d failed for SSID '%s': %s\n", data->attempt_number, data->ssid, error ? error->message : "unknown reason");
    }
    data->attempt_number++;
    try_next_wifi_step(data);
}

// This new function shows the password dialog as a last resort.
static void show_password_dialog(WifiAsyncData *data) {
    AdwAlertDialog *dialog = ADW_ALERT_DIALOG(adw_alert_dialog_new("Connection Failed", NULL));
    
    adw_alert_dialog_add_response(dialog, "cancel", "Cancel");
    adw_alert_dialog_add_response(dialog, "connect", "Connect");
    adw_alert_dialog_set_response_appearance(dialog, "connect", ADW_RESPONSE_SUGGESTED);
    adw_alert_dialog_set_default_response(dialog, "connect");

    GtkWidget *grid = gtk_grid_new();
    gtk_grid_set_column_spacing(GTK_GRID(grid), 10);
    gtk_grid_set_row_spacing(GTK_GRID(grid), 10);
    gtk_widget_set_margin_start(grid, 10);
    gtk_widget_set_margin_end(grid, 10);
    gtk_widget_set_margin_top(grid, 10);
    gtk_widget_set_margin_bottom(grid, 10);

    gtk_grid_attach(GTK_GRID(grid), gtk_label_new("Could not connect. Please enter the password."), 0, 0, 2, 1);
    gtk_grid_attach(GTK_GRID(grid), gtk_label_new("SSID:"), 0, 1, 1, 1);
    gtk_grid_attach(GTK_GRID(grid), gtk_label_new(data->ssid), 1, 1, 1, 1);
    gtk_grid_attach(GTK_GRID(grid), gtk_label_new("Password:"), 0, 2, 1, 1);
    GtkWidget *entry = gtk_password_entry_new();
    gtk_widget_set_hexpand(entry, TRUE);
    gtk_grid_attach(GTK_GRID(grid), entry, 1, 2, 1, 1);
    gtk_widget_grab_focus(entry);

    adw_alert_dialog_set_extra_child(dialog, grid);
    
    g_object_set_data(G_OBJECT(dialog), "password-entry", entry);
    adw_alert_dialog_choose(dialog, GTK_WIDGET(data->parent_window), NULL, (GAsyncReadyCallback)on_password_dialog_response, data);
}

// This is called after the user responds to the password dialog.
static void on_password_dialog_response(GObject *source, GAsyncResult *result, gpointer user_data) {
    AdwAlertDialog *dialog = ADW_ALERT_DIALOG(source);
    WifiAsyncData *data = user_data;
    GtkEditable *entry = g_object_get_data(G_OBJECT(dialog), "password-entry");
    const gchar *response_id = adw_alert_dialog_choose_finish(dialog, result);

    if (g_str_equal(response_id, "connect")) {
        const gchar *password_text = gtk_editable_get_text(entry);
        
        if (!password_text || !*password_text) {
             g_print("Password dialog submitted with no password. Cancelling.\n");
             g_free(data->ssid);
             g_free(data->password);
             g_free(data);
             return;
        }

        g_print("Retrying connection with user-provided password.\n");
        g_free(data->password);
        data->password = g_strdup(password_text);
        data->attempt_number = 1; // Restart the process, skipping the first 'up' attempt.
        try_next_wifi_step(data);
    } else {
        // User clicked "Cancel", so we clean up.
        g_print("Password dialog cancelled.\n");
        g_free(data->ssid);
        g_free(data->password);
        g_free(data);
    }
}

static void on_wifi_scan_ready(GObject *source_object, GAsyncResult *res, gpointer user_data) {
    (void)source_object;
    GtkBox *box = GTK_BOX(user_data);
    const char *out = get_command_stdout(res);
    if (!out) return;

    gchar *active_ssid = NULL;
    gchar **lines = g_strsplit(out, "\n", -1);
    for (int i = 0; lines[i]; i++) {
        if (g_str_has_prefix(lines[i], "yes:")) {
            gchar **parts = g_strsplit(lines[i], ":", 2);
            if (g_strv_length(parts) > 1) {
                active_ssid = g_strdup(parts[1]);
            }
            g_strfreev(parts);
            break;
        }
    }

    GtkWidget *child;
    while ((child = gtk_widget_get_first_child(GTK_WIDGET(box)))) {
        gtk_box_remove(box, child);
    }

    for (int i = 0; lines[i] && *lines[i]; i++) {
        gchar **parts = g_strsplit(lines[i], ":", 2);
        const char *ssid = parts[1];
        if (!ssid || !*ssid) { g_strfreev(parts); continue; }

        GtkWidget *row = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);
        
        WifiClickData *click_data = g_new(WifiClickData, 1);
        click_data->ssid = g_strdup(ssid);
        click_data->list_box = GTK_WIDGET(box);

        if (active_ssid && g_str_equal(ssid, active_ssid)) {
            GtkWidget *label = gtk_label_new(NULL);
            char *markup = g_strdup_printf("<b>%s</b>", ssid);
            gtk_label_set_markup(GTK_LABEL(label), markup);
            g_free(markup);
            gtk_widget_set_hexpand(label, TRUE);
            gtk_label_set_xalign(GTK_LABEL(label), 0.0);
            
            GtkWidget *button = gtk_button_new_with_label("Disconnect");
            
            g_free(click_data->ssid);
            click_data->ssid = g_strdup("");
            g_signal_connect_data(button, "clicked", G_CALLBACK(on_wifi_connect_clicked),
                                  click_data, (GClosureNotify)free_wifi_click_data, 0);

            gtk_box_append(GTK_BOX(row), label);
            gtk_box_append(GTK_BOX(row), button);
        } else {
            GtkWidget *button = gtk_button_new_with_label(ssid);
            gtk_button_set_has_frame(GTK_BUTTON(button), FALSE);
            gtk_widget_set_hexpand(button, TRUE);
            GtkWidget *label_child = gtk_button_get_child(GTK_BUTTON(button));
            if (GTK_IS_LABEL(label_child)) {
                gtk_label_set_xalign(GTK_LABEL(label_child), 0.0);
            }
            
            g_signal_connect_data(button, "clicked", G_CALLBACK(on_wifi_connect_clicked),
                                  click_data, (GClosureNotify)free_wifi_click_data, 0);

            gtk_box_append(GTK_BOX(row), button);
        }
        gtk_box_append(GTK_BOX(box), row);
        g_strfreev(parts);
    }
    g_strfreev(lines);
    g_free(active_ssid);
}

static gboolean trigger_wifi_scan_refresh(gpointer user_data) {
    GtkBox *box = GTK_BOX(user_data);
    if (!gtk_widget_get_visible(GTK_WIDGET(box))) return G_SOURCE_REMOVE;
    execute_command_async("nmcli -t -f active,ssid dev wifi", on_wifi_scan_ready, box);
    return G_SOURCE_CONTINUE;
}

static void on_wifi_panel_destroy(GtkWidget *widget, gpointer user_data) {
    (void)user_data;
    guint timer_id = GPOINTER_TO_UINT(g_object_get_data(G_OBJECT(widget), "wifi-refresh-timer-id"));
    if (timer_id) g_source_remove(timer_id);
}

static void on_wifi_panel_state_set(GtkSwitch *sw, gboolean state, gpointer d) {
    (void)sw; (void)d;
    execute_command_async(state ? "nmcli radio wifi on" : "nmcli radio wifi off", NULL, NULL);
}

static void on_wifi_panel_status_ready(GObject *s, GAsyncResult *res, gpointer d) {
    (void)s;
    GtkSwitch *sw = GTK_SWITCH(d);
    const char *out = get_command_stdout(res);
    gtk_switch_set_active(sw, out && strcmp(out, "enabled\n") == 0);
}


// --- Bluetooth Callbacks ---
static void free_bt_action_data(gpointer d, GClosure *closure) {
    (void)closure;
    BtActionData *ad = d;
    g_free(ad->mac_address);
    g_free(ad);
}
static void on_bt_connect_clicked(GtkButton *b, gpointer user_data) {
    (void)b;
    BtActionData *data = user_data;
    char cmd[256];
    snprintf(cmd, sizeof(cmd), "bluetoothctl connect %s", data->mac_address);
    execute_command_async(cmd, on_bt_list_needs_refresh, data->list_box);
}
static void on_bt_disconnect_clicked(GtkButton *b, gpointer user_data) {
    (void)b;
    BtActionData *data = user_data;
    char cmd[256];
    snprintf(cmd, sizeof(cmd), "bluetoothctl disconnect %s", data->mac_address);
    execute_command_async(cmd, on_bt_list_needs_refresh, data->list_box);
}
static void on_bt_paired_devices_ready(GObject *s, GAsyncResult *res, gpointer d) {
    (void)s;
    WifiUpdateData *data = d;
    const char *out = get_command_stdout(res);
    if (!out) { g_free(data->active_ssid); g_free(data); return; }
    GtkBox *list_box = data->list_box;
    GtkWidget *child;
    while ((child = gtk_widget_get_first_child(GTK_WIDGET(list_box))))
        gtk_box_remove(list_box, child);
    gchar **lines = g_strsplit(out, "\n", -1);
    for (int i = 0; lines[i]; i++) {
        gchar *mac = NULL, *name = NULL;
        if (sscanf(lines[i], "Device %ms %m[^\n]", &mac, &name) == 2) {
            GtkWidget *row = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);
            BtActionData *ad = g_new0(BtActionData, 1);
            ad->mac_address = g_strdup(mac);
            ad->list_box = GTK_WIDGET(list_box);
            if (data->active_ssid && strstr(data->active_ssid, mac)) {
                GtkWidget *label = gtk_label_new(NULL);
                char *markup = g_strdup_printf("<b>%s</b>", name);
                gtk_label_set_markup(GTK_LABEL(label), markup);
                g_free(markup);
                gtk_widget_set_hexpand(label, TRUE);
                gtk_label_set_xalign(GTK_LABEL(label), 0.0);
                GtkWidget *button = gtk_button_new_with_label("Disconnect");
                g_signal_connect_data(button, "clicked",
                                       G_CALLBACK(on_bt_disconnect_clicked),
                                       ad, (GClosureNotify)free_bt_action_data, 0);
                gtk_box_append(GTK_BOX(row), label);
                gtk_box_append(GTK_BOX(row), button);
            } else {
                GtkWidget *button = gtk_button_new_with_label(name);
                gtk_button_set_has_frame(GTK_BUTTON(button), FALSE);
                gtk_widget_set_hexpand(button, TRUE);
                gtk_label_set_xalign(GTK_LABEL(gtk_button_get_child(GTK_BUTTON(button))), 0.0);
                g_signal_connect_data(button, "clicked",
                                       G_CALLBACK(on_bt_connect_clicked),
                                       ad, (GClosureNotify)free_bt_action_data, 0);
                gtk_box_append(GTK_BOX(row), button);
            }
            gtk_box_append(GTK_BOX(list_box), row);
            g_free(mac); g_free(name);
        }
    }
    g_strfreev(lines);
    g_free(data->active_ssid);
    g_free(data);
}
static void on_bt_connected_devices_ready(GObject *s, GAsyncResult *res, gpointer d) {
    (void)s;
    const char *out = get_command_stdout(res);
    WifiUpdateData *data = g_new0(WifiUpdateData, 1);
    data->list_box = GTK_BOX(d);
    data->active_ssid = g_strdup(out);
    execute_command_async("bluetoothctl devices Paired", on_bt_paired_devices_ready, data);
}
static void on_bt_list_needs_refresh(GObject *s, GAsyncResult *res, gpointer d) {
    (void)s; (void)res;
    g_timeout_add_seconds(2, trigger_bt_refresh, d);
}
static gboolean trigger_bt_refresh(gpointer user_data) {
    GtkWidget *box = GTK_WIDGET(user_data);
    if (!gtk_widget_get_visible(box)) return G_SOURCE_REMOVE;
    execute_command_async("bluetoothctl devices Connected",
                          on_bt_connected_devices_ready, box);
    return G_SOURCE_CONTINUE;
}
static void on_bt_panel_state_set(GtkSwitch *sw, gboolean state, gpointer d) {
    (void)sw; (void)d;
    execute_command_async(state ? "bluetoothctl power on"
                                : "bluetoothctl power off",
                          NULL, NULL);
}
static void on_bt_panel_status_ready(GObject *s, GAsyncResult *res, gpointer d) {
    (void)s;
    GtkSwitch *bs = GTK_SWITCH(d);
    const char *o = get_command_stdout(res);
    gtk_switch_set_active(bs, o && strstr(o, "Powered: yes"));
}
static void on_bt_panel_destroy(GtkWidget *widget, gpointer user_data) {
    (void)user_data;
    guint timer_id = GPOINTER_TO_UINT(
        g_object_get_data(G_OBJECT(widget), "bt-refresh-timer-id"));
    if (timer_id) g_source_remove(timer_id);
}

// --- Panel Creation Functions ---
GtkWidget* create_audio_panel(GtkApplication *app, GtkWidget *parent_window, int top_margin) {
    GtkWidget *window = gtk_application_window_new(app);
    gtk_window_set_transient_for(GTK_WINDOW(window), GTK_WINDOW(parent_window));
    gtk_window_set_default_size(GTK_WINDOW(window), 250, -1);
    gtk_layer_init_for_window(GTK_WINDOW(window));
    gtk_layer_set_layer(GTK_WINDOW(window), GTK_LAYER_SHELL_LAYER_TOP);
    gtk_layer_set_anchor(GTK_WINDOW(window), GTK_LAYER_SHELL_EDGE_TOP, TRUE);
    gtk_layer_set_anchor(GTK_WINDOW(window), GTK_LAYER_SHELL_EDGE_LEFT, TRUE);
    gtk_layer_set_margin(GTK_WINDOW(window), GTK_LAYER_SHELL_EDGE_LEFT, MAIN_SIDEBAR_WIDTH);
    gtk_layer_set_margin(GTK_WINDOW(window), GTK_LAYER_SHELL_EDGE_TOP, top_margin); // MODIFIED
    GtkWidget *audio_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 10);
    gtk_widget_set_margin_start(audio_box, 10);
    gtk_widget_set_margin_end(audio_box, 10);
    gtk_widget_set_margin_top(audio_box, 10);
    gtk_widget_set_margin_bottom(audio_box, 10);
    ControlWidgets *widgets = g_new0(ControlWidgets, 1);
    widgets->volume_slider = gtk_scale_new_with_range(GTK_ORIENTATION_HORIZONTAL, 0, 100, 1);
    gtk_widget_set_hexpand(widgets->volume_slider, TRUE);
    g_signal_connect(widgets->volume_slider, "value-changed",
                     G_CALLBACK(on_volume_changed), NULL);
    gtk_box_append(GTK_BOX(audio_box), widgets->volume_slider);
    widgets->output_selector = gtk_drop_down_new(NULL, NULL);
    gtk_widget_set_hexpand(widgets->output_selector, TRUE);
    g_signal_connect(widgets->output_selector, "notify::selected",
                     G_CALLBACK(on_sink_selected), widgets);
    gtk_box_append(GTK_BOX(audio_box), widgets->output_selector);
    execute_command_async("wpctl get-volume @DEFAULT_SINK@",
                          on_initial_volume_ready,
                          widgets->volume_slider);
    execute_command_async("wpctl status", on_sinks_ready,
                          widgets->output_selector);
    gtk_window_set_child(GTK_WINDOW(window), audio_box);
    g_object_set_data_full(G_OBJECT(window), "widgets-bundle",
                          widgets, (GDestroyNotify)g_free);
    return window;
}

GtkWidget* create_wifi_panel(GtkApplication *app, GtkWidget *parent_window, int top_margin) {
    GtkWidget *window = gtk_application_window_new(app);
    gtk_window_set_transient_for(GTK_WINDOW(window), GTK_WINDOW(parent_window));
    gtk_window_set_default_size(GTK_WINDOW(window), 280, 400);
    gtk_layer_init_for_window(GTK_WINDOW(window));
    gtk_layer_set_layer(GTK_WINDOW(window), GTK_LAYER_SHELL_LAYER_TOP);
    gtk_layer_set_anchor(GTK_WINDOW(window), GTK_LAYER_SHELL_EDGE_TOP, TRUE);
    gtk_layer_set_anchor(GTK_WINDOW(window), GTK_LAYER_SHELL_EDGE_LEFT, TRUE);
    gtk_layer_set_margin(GTK_WINDOW(window), GTK_LAYER_SHELL_EDGE_LEFT, MAIN_SIDEBAR_WIDTH);
    gtk_layer_set_margin(GTK_WINDOW(window), GTK_LAYER_SHELL_EDGE_TOP, top_margin); // MODIFIED

    AdwToastOverlay *toast_overlay = ADW_TOAST_OVERLAY(adw_toast_overlay_new());
    g_object_set_data(G_OBJECT(window), "toast-overlay", toast_overlay);

    GtkWidget *main_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 15);
    gtk_widget_set_margin_start(main_box, 10);
    gtk_widget_set_margin_end(main_box, 10);
    gtk_widget_set_margin_top(main_box, 10);
    gtk_widget_set_margin_bottom(main_box, 10);

    GtkWidget *toggle_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);
    GtkWidget *toggle_label = gtk_label_new("Wi-Fi");
    GtkWidget *wifi_switch = gtk_switch_new();
    gtk_widget_set_hexpand(toggle_label, TRUE);
    gtk_label_set_xalign(GTK_LABEL(toggle_label), 0.0);
    g_signal_connect(wifi_switch, "state-set", G_CALLBACK(on_wifi_panel_state_set), NULL);
    execute_command_async("nmcli radio wifi", on_wifi_panel_status_ready, wifi_switch);
    gtk_box_append(GTK_BOX(toggle_box), toggle_label);
    gtk_box_append(GTK_BOX(toggle_box), wifi_switch);
    gtk_box_append(GTK_BOX(main_box), toggle_box);

    gtk_box_append(GTK_BOX(main_box), gtk_separator_new(GTK_ORIENTATION_HORIZONTAL));

    GtkWidget *scrolled_window = gtk_scrolled_window_new();
    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolled_window), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
    gtk_widget_set_vexpand(scrolled_window, TRUE);

    GtkWidget *list_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);
    gtk_scrolled_window_set_child(GTK_SCROLLED_WINDOW(scrolled_window), list_box);
    gtk_box_append(GTK_BOX(main_box), scrolled_window);

    guint timer_id = g_timeout_add_seconds(2, trigger_wifi_scan_refresh, list_box);
    g_object_set_data(G_OBJECT(window), "wifi-refresh-timer-id", GUINT_TO_POINTER(timer_id));
    g_signal_connect(window, "destroy", G_CALLBACK(on_wifi_panel_destroy), NULL);
    trigger_wifi_scan_refresh(list_box);

    adw_toast_overlay_set_child(toast_overlay, main_box);
    gtk_window_set_child(GTK_WINDOW(window), GTK_WIDGET(toast_overlay));
    return window;
}

GtkWidget* create_bluetooth_panel(GtkApplication *app, GtkWidget *parent_window, int top_margin) {
    GtkWidget *window = gtk_application_window_new(app);
    gtk_window_set_transient_for(GTK_WINDOW(window), GTK_WINDOW(parent_window));
    gtk_window_set_default_size(GTK_WINDOW(window), 280, 400);
    gtk_layer_init_for_window(GTK_WINDOW(window));
    gtk_layer_set_layer(GTK_WINDOW(window), GTK_LAYER_SHELL_LAYER_TOP);
    gtk_layer_set_anchor(GTK_WINDOW(window), GTK_LAYER_SHELL_EDGE_TOP, TRUE);
    gtk_layer_set_anchor(GTK_WINDOW(window), GTK_LAYER_SHELL_EDGE_LEFT, TRUE);
    gtk_layer_set_margin(GTK_WINDOW(window), GTK_LAYER_SHELL_EDGE_LEFT, MAIN_SIDEBAR_WIDTH);
    gtk_layer_set_margin(GTK_WINDOW(window), GTK_LAYER_SHELL_EDGE_TOP, top_margin); // MODIFIED

    GtkWidget *main_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 15);
    gtk_widget_set_margin_start(main_box, 10);
    gtk_widget_set_margin_end(main_box, 10);
    gtk_widget_set_margin_top(main_box, 10);
    gtk_widget_set_margin_bottom(main_box, 10);

    GtkWidget *toggle_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);
    GtkWidget *toggle_label = gtk_label_new("Bluetooth");
    GtkWidget *bt_switch = gtk_switch_new();
    gtk_widget_set_hexpand(toggle_label, TRUE);
    gtk_label_set_xalign(GTK_LABEL(toggle_label), 0.0);
    g_signal_connect(bt_switch, "state-set", G_CALLBACK(on_bt_panel_state_set), NULL);
    execute_command_async("bluetoothctl show", on_bt_panel_status_ready, bt_switch);
    gtk_box_append(GTK_BOX(toggle_box), toggle_label);
    gtk_box_append(GTK_BOX(toggle_box), bt_switch);
    gtk_box_append(GTK_BOX(main_box), toggle_box);

    gtk_box_append(GTK_BOX(main_box), gtk_separator_new(GTK_ORIENTATION_HORIZONTAL));

    GtkWidget *scrolled_window = gtk_scrolled_window_new();
    gtk_widget_set_vexpand(scrolled_window, TRUE);
    GtkWidget *list_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);
    gtk_scrolled_window_set_child(GTK_SCROLLED_WINDOW(scrolled_window), list_box);
    gtk_box_append(GTK_BOX(main_box), scrolled_window);

    guint timer_id = g_timeout_add_seconds(5, trigger_bt_refresh, list_box);
    g_object_set_data(G_OBJECT(window), "bt-refresh-timer-id", GUINT_TO_POINTER(timer_id));
    g_signal_connect(window, "destroy", G_CALLBACK(on_bt_panel_destroy), NULL);
    trigger_bt_refresh(list_box);

    gtk_window_set_child(GTK_WINDOW(window), main_box);
    return window;
}===== src/control_center.c =====
#include "control_center.h"
#include "popout_panels.h"
#include <gtk/gtk.h>
#include <gtk-layer-shell/gtk-layer-shell.h>

// Fixed vertical position for each popout (pixels from top of window)
static const int POPUP_TOP_AUDIO = 290;
static const int POPUP_TOP_WIFI = 150;
static const int POPUP_TOP_BT   = 180;

// Horizontal adjustment: push farther right (pixels)
// This is added to the sidebar width margin
static const int POPUP_HORZ_ADJUST = 20;

// Track the currently open popout window and click controller
static GtkWidget *current_popout = NULL;
static GtkEventController *outside_click_controller = NULL;


// Forward declaration for the function that will attach the controller
static gboolean attach_click_outside_controller(gpointer user_data);


// Helper to clean up and destroy the current popout
static void destroy_current_popout(void) {
    if (!current_popout) {
        return;
    }

    // The widget owns the controller, so destroying the window will handle
    // its cleanup. We just need to null out our global pointers.
    gtk_window_destroy(GTK_WINDOW(current_popout));
    current_popout = NULL;
    
    // g_clear_object will unref the controller and set the pointer to NULL.
    if (outside_click_controller) {
        g_clear_object(&outside_click_controller);
    }
}

// Callback for clicks. This is now smarter.
// It closes the popout only if the click is truly *outside* its bounds.
static void on_click_outside(GtkGestureClick *gesture,
                             int n_press,
                             double x,
                             double y,
                             gpointer user_data) {
    GtkWidget* popout_widget = GTK_WIDGET(user_data);
    GtkAllocation allocation;

    // Get the size of the popout window
    gtk_widget_get_allocation(popout_widget, &allocation);

    // Check if the click coordinates (x, y) are inside the widget's allocation
    if (x >= 0 && y >= 0 && x < allocation.width && y < allocation.height) {
        // The click was *inside* the popout, so do nothing.
        return;
    }

    // The click was outside, so destroy the popout.
    destroy_current_popout();
}


// This function is now called by g_idle_add() to attach the controller
// after the current event cycle has finished, fixing the race condition.
static gboolean attach_click_outside_controller(gpointer user_data) {
    // If the popout was closed for some other reason before this idle
    // callback ran, just do nothing.
    if (!current_popout) {
        return G_SOURCE_REMOVE;
    }

    outside_click_controller = GTK_EVENT_CONTROLLER(gtk_gesture_click_new());
    
    // CAPTURE phase gets the event before any widgets inside the window do.
    gtk_event_controller_set_propagation_phase(outside_click_controller, GTK_PHASE_CAPTURE);
    
    // Connect the "pressed" signal. We pass `current_popout` as user_data so the
    // handler knows which widget to check the bounds of.
    g_signal_connect(outside_click_controller, "pressed", G_CALLBACK(on_click_outside), current_popout);

    gtk_widget_add_controller(current_popout, outside_click_controller);

    // Return G_SOURCE_REMOVE so this function only runs once per popout.
    return G_SOURCE_REMOVE;
}


// Toggle a named popout, cleaning up any existing one
static void toggle_popout(GtkApplication *app, GtkWidget *trigger, const char *name) {
    // If a popout is already open...
    if (current_popout) {
        const char *open_name = g_object_get_data(G_OBJECT(current_popout), "popout-name");
        destroy_current_popout();
        // If the user clicked the same button again, we just close the popout and stop.
        if (g_strcmp0(open_name, name) == 0) {
            return;
        }
    }

    // Determine vertical top based on popout type
    int y_pos;
    if (g_strcmp0(name, "audio") == 0)      y_pos = POPUP_TOP_AUDIO;
    else if (g_strcmp0(name, "wifi") == 0)  y_pos = POPUP_TOP_WIFI;
    else if (g_strcmp0(name, "bluetooth") == 0) y_pos = POPUP_TOP_BT;
    else                                     y_pos = POPUP_TOP_AUDIO; // Default

    // Create the popout panel
    GtkWindow *parent = GTK_WINDOW(gtk_widget_get_ancestor(trigger, GTK_TYPE_WINDOW));
    GtkWidget *pop = NULL;
    if (g_strcmp0(name, "audio") == 0)
        pop = create_audio_panel(app, GTK_WIDGET(parent), y_pos);
    else if (g_strcmp0(name, "wifi") == 0)
        pop = create_wifi_panel(app, GTK_WIDGET(parent), y_pos);
    else if (g_strcmp0(name, "bluetooth") == 0)
        pop = create_bluetooth_panel(app, GTK_WIDGET(parent), y_pos);
    
    if (!pop) return;

    g_object_set_data(G_OBJECT(pop), "popout-name", (gpointer)name);

    // Layer-shell positioning
    int sidebar_width = gtk_widget_get_width(GTK_WIDGET(parent));
    gtk_layer_init_for_window(GTK_WINDOW(pop));
    gtk_layer_set_anchor(GTK_WINDOW(pop), GTK_LAYER_SHELL_EDGE_LEFT, TRUE);
    gtk_layer_set_margin(GTK_WINDOW(pop), GTK_LAYER_SHELL_EDGE_LEFT, sidebar_width + POPUP_HORZ_ADJUST);
    gtk_layer_set_anchor(GTK_WINDOW(pop), GTK_LAYER_SHELL_EDGE_TOP, TRUE);
    gtk_layer_set_margin(GTK_WINDOW(pop), GTK_LAYER_SHELL_EDGE_TOP, y_pos);
    gtk_layer_set_layer(GTK_WINDOW(pop), GTK_LAYER_SHELL_LAYER_TOP);

    gtk_window_present(GTK_WINDOW(pop));
    current_popout = pop;

    // *** THE FIX ***
    // Schedule the attachment of the click-outside controller to happen
    // when the main loop is idle. This prevents it from catching the same
    // click that opened the popout.
    g_idle_add(attach_click_outside_controller, NULL);
}

// Button signal handlers
static void on_audio_icon_clicked(GtkButton *button, gpointer user_data) {
    toggle_popout(GTK_APPLICATION(user_data), GTK_WIDGET(button), "audio");
}
static void on_wifi_icon_clicked(GtkButton *button, gpointer user_data) {
    toggle_popout(GTK_APPLICATION(user_data), GTK_WIDGET(button), "wifi");
}
static void on_bluetooth_icon_clicked(GtkButton *button, gpointer user_data) {
    toggle_popout(GTK_APPLICATION(user_data), GTK_WIDGET(button), "bluetooth");
}
static void on_back_button_clicked(GtkButton *button, gpointer user_data) {
    destroy_current_popout();
    gtk_stack_set_visible_child_name(GTK_STACK(user_data), "dock");
}

// Build the control center view
GtkWidget* create_control_center_view(GtkApplication *app, GtkStack *stack) {
    GtkWidget *box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 10);
    gtk_widget_set_valign(box, GTK_ALIGN_START);
    gtk_widget_set_margin_top(box, 10);

    GtkWidget *back_button = gtk_button_new_from_icon_name("go-previous-symbolic"); // A more standard icon for "back"
    g_signal_connect(back_button, "clicked", G_CALLBACK(on_back_button_clicked), stack);
    gtk_box_append(GTK_BOX(box), back_button);

    gtk_box_append(GTK_BOX(box), gtk_separator_new(GTK_ORIENTATION_HORIZONTAL));

    GtkWidget *audio_button = gtk_button_new_from_icon_name("audio-card-symbolic");
    g_signal_connect(audio_button, "clicked", G_CALLBACK(on_audio_icon_clicked), app);
    gtk_box_append(GTK_BOX(box), audio_button);

    GtkWidget *wifi_button = gtk_button_new_from_icon_name("network-wireless-symbolic");
    g_signal_connect(wifi_button, "clicked", G_CALLBACK(on_wifi_icon_clicked), app);
    gtk_box_append(GTK_BOX(box), wifi_button);

    GtkWidget *bt_button = gtk_button_new_from_icon_name("bluetooth-symbolic");
    g_signal_connect(bt_button, "clicked", G_CALLBACK(on_bluetooth_icon_clicked), app);
    gtk_box_append(GTK_BOX(box), bt_button);

    return box;
}===== src/app_dock.c =====
#include <gtk/gtk.h>
#include <gio/gio.h>
#include <graphene.h>
#include "app_dock.h"
#include "utils.h"
#include <json-glib/json-glib.h>
#include <glib/gstdio.h>
#include <sys/types.h>

// DATA STRUCTURES
typedef struct { gchar *address; gchar *class_name; pid_t pid; } ClientInfo;
typedef struct { gchar *class_name; gchar *exec_cmd; gboolean is_running; GtkWidget *button; } PinnedIconData;
typedef struct { gchar *class_name; pid_t pid; } UnpinnedIconData;
typedef struct { gchar *class_name; pid_t pid; } ActionData;

// GLOBAL STATE
static GHashTable *clients_map = NULL;
static GtkWidget *pinned_apps_container = NULL;
static GtkWidget *running_apps_container = NULL;
static GtkWidget *app_dock_popover = NULL;
static GtkWidget *running_apps_separator = NULL;

// FORWARD DECLARATIONS
static void redraw_ui_from_map(void);
static void bootstrap_clients(void);

// HELPER & CALLBACK FUNCTIONS
static void free_client_info(gpointer data) { ClientInfo *c = data; if (!c) return; g_free(c->address); g_free(c->class_name); g_free(c); }
static void free_pinned_icon_data(gpointer data) { PinnedIconData *d = data; if (!d) return; g_free(d->class_name); g_free(d->exec_cmd); g_free(d); }
static void free_unpinned_icon_data(gpointer data) { UnpinnedIconData *d = data; if (!d) return; g_free(d->class_name); g_free(d); }
static void free_action_data(gpointer data, GClosure *closure) { (void)closure; ActionData *d = data; if (!d) return; g_free(d->class_name); g_free(d); }

static gchar* get_pinned_apps_path(void) { return g_strdup("../src/pinned.json"); }

static GList* load_pinned_apps(void) {
    g_autofree gchar *file_path = get_pinned_apps_path();
    if (!g_file_test(file_path, G_FILE_TEST_EXISTS)) return NULL;
    g_autoptr(GError) error = NULL;
    g_autoptr(JsonParser) parser = json_parser_new();
    if (!json_parser_load_from_file(parser, file_path, &error)) { return NULL; }
    JsonArray *array = json_node_get_array(json_parser_get_root(parser));
    if (!array) return NULL;
    GList *pinned_list = NULL;
    for (guint i = 0; i < json_array_get_length(array); i++) {
        JsonObject *obj = json_array_get_object_element(array, i);
        PinnedIconData *info = g_new0(PinnedIconData, 1);
        info->class_name = g_strdup(json_object_get_string_member(obj, "class"));
        info->exec_cmd   = g_strdup(json_object_get_string_member(obj, "exec"));
        pinned_list = g_list_append(pinned_list, info);
    }
    return g_list_reverse(pinned_list);
}

static void save_pinned_apps(GList *pinned_list) {
    JsonBuilder *builder = json_builder_new();
    json_builder_begin_array(builder);
    for (GList *l = pinned_list; l; l = l->next) {
        PinnedIconData *info = l->data;
        json_builder_begin_object(builder);
        json_builder_set_member_name(builder, "class"); json_builder_add_string_value(builder, info->class_name);
        json_builder_set_member_name(builder, "exec");  json_builder_add_string_value(builder, info->exec_cmd);
        json_builder_end_object(builder);
    }
    json_builder_end_array(builder);
    JsonNode *root = json_builder_get_root(builder);
    g_autoptr(JsonGenerator) generator = json_generator_new();
    json_generator_set_root(generator, root);
    json_generator_set_pretty(generator, TRUE);
    g_autofree gchar *str = json_generator_to_data(generator, NULL);
    g_autoptr(GError) error = NULL;
    if (!g_file_set_contents(get_pinned_apps_path(), str, -1, &error)) { g_warning("Failed to save pinned apps: %s", error->message); }
    g_object_unref(builder);
}

static void on_pinned_app_clicked(GtkButton *button, gpointer user_data) {
    (void)user_data; // This will be NULL, we ignore it.
    
    // Get the data directly from the widget itself. This is the safe way.
    PinnedIconData *data = g_object_get_data(G_OBJECT(button), "pinned-data");
    if (!data) return; // Should not happen, but good to be safe.

    char cmd[256];
    if (data->is_running)
        snprintf(cmd, sizeof(cmd), "hyprctl dispatch focuswindow class:^(%s)$", data->class_name);
    else
        snprintf(cmd, sizeof(cmd), "%s", data->exec_cmd);
    execute_command_async(cmd, NULL, NULL);
}

static void on_running_app_clicked(GtkButton *button, gpointer user_data) {
    UnpinnedIconData *data = user_data; char cmd[256];
    snprintf(cmd, sizeof(cmd), "hyprctl dispatch focuswindow class:^(%s)$", data->class_name);
    execute_command_async(cmd, NULL, NULL);
}

static void on_unpin_app_clicked(GtkButton *popover_button, gpointer user_data) {
    (void)popover_button;
    ActionData *data = user_data;
    GList *list = load_pinned_apps();
    GList *found = NULL;
    for (GList *l = list; l; l = l->next) {
        if (g_strcmp0(((PinnedIconData*)l->data)->class_name, data->class_name) == 0) {
            found = l;
            break;
        }
    }
    if (found) { list = g_list_delete_link(list, found); save_pinned_apps(list); }
    g_list_free_full(list, free_pinned_icon_data);
    redraw_ui_from_map();
}

static void on_app_icon_right_clicked(GtkGestureClick *gesture, gint n_press, gdouble x, gdouble y, gpointer user_data) {
    (void)n_press; (void)x; (void)y; (void)user_data;
    if (gtk_gesture_single_get_current_button(GTK_GESTURE_SINGLE(gesture)) != GDK_BUTTON_SECONDARY) return;

    // Properly remove existing popover
    if (app_dock_popover) {
        gtk_popover_popdown(GTK_POPOVER(app_dock_popover));
        gtk_widget_unparent(app_dock_popover);
        g_clear_object(&app_dock_popover);
    }

    GtkWidget *button = gtk_event_controller_get_widget(GTK_EVENT_CONTROLLER(gesture));
    GtkWidget *toplevel = gtk_widget_get_ancestor(button, GTK_TYPE_WINDOW);

    app_dock_popover = gtk_popover_new();
    gtk_widget_set_parent(app_dock_popover, toplevel);
    gtk_popover_set_autohide(GTK_POPOVER(app_dock_popover), TRUE);

    graphene_point_t top_left = { .x = 0, .y = 0 };
    graphene_point_t computed_point;
    gtk_widget_compute_point(button, toplevel, &top_left, &computed_point);

    GdkRectangle rect = {
        .x = computed_point.x,
        .y = computed_point.y,
        .width = gtk_widget_get_width(button),
        .height = gtk_widget_get_height(button)
    };
    gtk_popover_set_pointing_to(GTK_POPOVER(app_dock_popover), &rect);

    GtkWidget *box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);
    PinnedIconData *pinned = g_object_get_data(G_OBJECT(button), "pinned-data");

    if (pinned) {
        GtkWidget *unpin_btn = gtk_button_new_with_label("Unpin");
        ActionData *action = g_new0(ActionData, 1);
        action->class_name = g_strdup(pinned->class_name);
        g_signal_connect_data(unpin_btn, "clicked", G_CALLBACK(on_unpin_app_clicked), action, (GClosureNotify)free_action_data, 0);
        gtk_box_append(GTK_BOX(box), unpin_btn);
    }

    gtk_popover_set_child(GTK_POPOVER(app_dock_popover), box);
    gtk_popover_popup(GTK_POPOVER(app_dock_popover));
}

// CORE LOGIC
// src/app_dock.c

// CORE LOGIC
static void redraw_ui_from_map(void) {
    // Remove any existing popover cleanly
    if (app_dock_popover) {
        gtk_popover_popdown(GTK_POPOVER(app_dock_popover));
        gtk_widget_unparent(app_dock_popover);
        g_clear_object(&app_dock_popover);
    }

    GtkWidget *child;
    while ((child = gtk_widget_get_first_child(pinned_apps_container))) gtk_widget_unparent(child);
    while ((child = gtk_widget_get_first_child(running_apps_container))) gtk_widget_unparent(child);

    // --- Use a hash set for efficient lookup of pinned apps ---
    GHashTable *pinned_set = g_hash_table_new(g_str_hash, g_str_equal);
    GList *pinned_config = load_pinned_apps();
    for (GList *l = pinned_config; l; l = l->next) {
        PinnedIconData *pin_data = l->data;
        // The key is the class name, value is not important so we use the key itself.
        g_hash_table_add(pinned_set, pin_data->class_name);
    }

    // --- Draw Pinned Apps ---
    for (GList *l = pinned_config; l; l = l->next) {
        PinnedIconData *pin_data = l->data;
        if (!pin_data) continue; // Skip if data was already transferred

        pin_data->is_running = FALSE;
        GHashTableIter live_iter; gpointer key, value;
        g_hash_table_iter_init(&live_iter, clients_map);
        while (g_hash_table_iter_next(&live_iter, &key, &value)) {
            if (g_strcmp0(((ClientInfo*)value)->class_name, pin_data->class_name) == 0) {
                pin_data->is_running = TRUE;
                break;
            }
        }
        
        pin_data->button = gtk_button_new_from_icon_name(pin_data->class_name);
        if (pin_data->is_running) {
            gtk_widget_add_css_class(pin_data->button, "running-app");
        }
        
        // The button now takes full ownership of the pin_data struct.
        g_object_set_data_full(G_OBJECT(pin_data->button), "pinned-data", pin_data, (GDestroyNotify)free_pinned_icon_data);
        
        // Pass NULL as user_data. The handler will get data from the button.
        g_signal_connect(pin_data->button, "clicked", G_CALLBACK(on_pinned_app_clicked), NULL);
        
        GtkGesture *rc = g_object_new(GTK_TYPE_GESTURE_CLICK, "button", GDK_BUTTON_SECONDARY, NULL);
        g_signal_connect(rc, "pressed", G_CALLBACK(on_app_icon_right_clicked), NULL);
        gtk_widget_add_controller(pin_data->button, GTK_EVENT_CONTROLLER(rc));
        gtk_box_append(GTK_BOX(pinned_apps_container), pin_data->button);

        // We've transferred ownership of pin_data to the button, so we NULL out the
        // pointer in the list to prevent a double-free when the list is freed.
        l->data = NULL;
    }
    // This now safely frees only the list nodes, as the data pointers are NULL.
    g_list_free(pinned_config);


    // --- Draw Unpinned Running Apps ---
    GHashTableIter iter; gpointer key, value;
    g_hash_table_iter_init(&iter, clients_map);
    while (g_hash_table_iter_next(&iter, &key, &value)) {
        ClientInfo *client = value;

        // EFFICIENT CHECK: If the app is in our pinned set, skip it.
        if (g_hash_table_contains(pinned_set, client->class_name)) {
            continue;
        }

        // This app is running but not pinned, so create a button for it.
        UnpinnedIconData *d = g_new0(UnpinnedIconData, 1);
        d->class_name = g_strdup(client->class_name); d->pid = client->pid;
        GtkWidget *btn = gtk_button_new_from_icon_name(d->class_name);
        gtk_widget_add_css_class(btn, "running-app");
        g_object_set_data_full(G_OBJECT(btn), "unpinned-data", d, free_unpinned_icon_data);
        g_signal_connect(btn, "clicked", G_CALLBACK(on_running_app_clicked), d);
        GtkGesture *rc = g_object_new(GTK_TYPE_GESTURE_CLICK, "button", GDK_BUTTON_SECONDARY, NULL);
        g_signal_connect(rc, "pressed", G_CALLBACK(on_app_icon_right_clicked), NULL);
        gtk_widget_add_controller(btn, GTK_EVENT_CONTROLLER(rc));
        gtk_box_append(GTK_BOX(running_apps_container), btn);
    }
    
    // Clean up the hash set.
    g_hash_table_destroy(pinned_set);

    // --- FINAL UI ADJUSTMENTS ---
    
    // Check if the running_apps_container has any children.
    GtkWidget *first_running_app = gtk_widget_get_first_child(running_apps_container);
    
    // Show the separator only if there is at least one unpinned running app.
    gtk_widget_set_visible(running_apps_separator, first_running_app != NULL);

    // Force the window to resize to fit the new content.
    // We get the top-level window by finding the ancestor of one of our containers.
    GtkWidget *toplevel = gtk_widget_get_ancestor(pinned_apps_container, GTK_TYPE_WINDOW);
    if (toplevel) {
        // Setting the default size to -1, -1 tells the window to use its
        // natural "preferred" size, which effectively makes it shrink-to-fit.
        gtk_window_set_default_size(GTK_WINDOW(toplevel), -1, -1);
    }
}

static void on_bootstrap_ready(GObject *source, GAsyncResult *res, gpointer user_data) {
    (void)source; (void)user_data;
    g_hash_table_remove_all(clients_map);
    const char *json = get_command_stdout(res);
    if (json) {
        g_autoptr(JsonParser) parser = json_parser_new();
        if (json_parser_load_from_data(parser, json, -1, NULL)) {
            JsonArray *arr = json_node_get_array(json_parser_get_root(parser));
            if (arr) {
                for (guint i = 0; i < json_array_get_length(arr); i++) {
                    JsonObject *obj = json_array_get_object_element(arr, i);
                    if (!json_object_get_boolean_member_with_default(obj, "hidden", FALSE)) {
                        const char* class_name = json_object_get_string_member(obj, "class");
                        if (class_name && *class_name) {
                            ClientInfo *client = g_new0(ClientInfo, 1);
                            client->address = g_strdup(json_object_get_string_member(obj, "address"));
                            client->class_name = g_strdup(class_name);
                            client->pid = (pid_t)json_object_get_int_member(obj, "pid");
                            g_hash_table_insert(clients_map, g_strdup(client->address), client);
                        }
                    }
                }
            }
        }
    }
    redraw_ui_from_map();
}

static void bootstrap_clients(void) {
    execute_command_async("hyprctl -j clients", on_bootstrap_ready, NULL);
}

static void process_ipc_event(const gchar* line) {
    if (!line) return;
    if (g_str_has_prefix(line, "openwindow>>")) {
        bootstrap_clients();
    } else if (g_str_has_prefix(line, "closewindow>>")) {
        const gchar *addr = line + strlen("closewindow>>");
        if (g_hash_table_remove(clients_map, addr)) redraw_ui_from_map();
    } else if (g_str_has_prefix(line, "activewindow>>") || g_str_has_prefix(line, "windowtitle>>") || g_str_has_prefix(line, "movewindow>>")) {
        bootstrap_clients();
    }
}

static void on_line_read(GObject *source, GAsyncResult *res, gpointer user_data);
static void start_line_reading(GDataInputStream *stream, GCancellable *cancellable) {
    g_data_input_stream_read_line_async(stream, 0, cancellable, on_line_read, g_object_ref(stream));
}
static void on_line_read(GObject *source, GAsyncResult *res, gpointer user_data) {
    (void)source;
    GDataInputStream *stream = G_DATA_INPUT_STREAM(user_data);
    g_autoptr(GError) error = NULL;
    g_autofree gchar *line = g_data_input_stream_read_line_finish(stream, res, NULL, &error);
    if (error) { g_warning("Hyprland socket error: %s", error->message); g_object_unref(stream); return; }
    if (!line) { g_info("Hyprland socket closed."); g_object_unref(stream); return; }
    process_ipc_event(line);
    start_line_reading(stream, NULL);
    g_object_unref(stream);
}

static void on_socket_connected(GObject *source, GAsyncResult *res, gpointer user_data) {
    (void)user_data;
    g_autoptr(GError) error = NULL;
    GSocketConnection *connection = g_socket_client_connect_finish(G_SOCKET_CLIENT(source), res, &error);
    if (error) { g_warning("Socket connection failed: %s. No live updates.", error->message); return; }
    g_info("Successfully connected to Hyprland socket for live events.");
    GInputStream *istream = g_io_stream_get_input_stream(G_IO_STREAM(connection));
    g_autoptr(GDataInputStream) dstream = g_data_input_stream_new(istream);
    start_line_reading(dstream, NULL);
    g_object_unref(connection);
}

static void setup_hyprland_ipc_listener(void) {
    const char *instance_sig = getenv("HYPRLAND_INSTANCE_SIGNATURE");
    if (!instance_sig) { g_warning("HYPRLAND_INSTANCE_SIGNATURE not set. No live updates."); return; }
    g_autofree gchar *socket_path = g_build_filename(g_get_user_runtime_dir(), "hypr", instance_sig, ".socket2.sock", NULL);
    g_autoptr(GSocketClient) client = g_socket_client_new();
    g_autoptr(GSocketAddress) address = g_unix_socket_address_new(socket_path);
    g_socket_client_connect_async(client, G_SOCKET_CONNECTABLE(address), NULL, on_socket_connected, NULL);
}

static void on_gear_clicked(GtkButton *button, GtkStack *stack) { (void)button; gtk_stack_set_visible_child_name(stack, "controls"); }

GtkWidget* create_dock_view(GtkStack *stack) {
    GtkWidget *box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 10);
    gtk_widget_set_halign(box, GTK_ALIGN_CENTER);
    gtk_widget_set_valign(box, GTK_ALIGN_START);
    gtk_widget_set_margin_top(box, 10);

    GtkWidget *gear = gtk_button_new_from_icon_name("emblem-system-symbolic");
    g_signal_connect(gear, "clicked", G_CALLBACK(on_gear_clicked), stack);
    gtk_box_append(GTK_BOX(box), gear);
    gtk_box_append(GTK_BOX(box), gtk_separator_new(GTK_ORIENTATION_HORIZONTAL));

    pinned_apps_container  = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);
    running_apps_container = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);
    gtk_box_append(GTK_BOX(box), pinned_apps_container);
    running_apps_separator = gtk_separator_new(GTK_ORIENTATION_HORIZONTAL);
    gtk_box_append(GTK_BOX(box), running_apps_separator);
    gtk_box_append(GTK_BOX(box), running_apps_container);

    clients_map = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, free_client_info);

    bootstrap_clients();
    setup_hyprland_ipc_listener();
    
    return box;
}
===== src/popout_panels.h =====
// src/popout_panels.h

#ifndef POPOUT_PANELS_H
#define POPOUT_PANELS_H

#include <gtk/gtk.h>

// MODIFIED: Added top_margin parameter to all creation functions.
GtkWidget* create_audio_panel(GtkApplication *app, GtkWidget *parent_window, int top_margin);
GtkWidget* create_wifi_panel(GtkApplication *app, GtkWidget *parent_window, int top_margin);
GtkWidget* create_bluetooth_panel(GtkApplication *app, GtkWidget *parent_window, int top_margin);

#endif===== src/main.c =====
// src/main.c

#include <gtk/gtk.h>
#include <gtk4-layer-shell.h>
#include <json-glib/json-glib.h>

#include <pipewire/pipewire.h>
#include <spa/param/audio/raw.h>
#include <spa/param/format.h>
#include <spa/pod/builder.h>
#include <spa/param/audio/format-utils.h>

#include <fftw3.h>
#include <math.h>
#include <pthread.h>

#include "app_dock.h"
#include "control_center.h"

// Constants
#define RATE 48000
#define CHANNELS 2
#define SAMPLES 1024
#define NUM_BARS 16
#define CONFIG_FILE_PATH "config.json"

// App State Struct
typedef struct {
    GtkApplication *app;
    GtkWidget *sidebar_window;
    GtkWidget *handle_window;
    GtkWidget *drawing_area;
    GtkWidget *main_content_box;
    GtkWidget *stack;
    GtkWidget *idle_toggle_button;
    guint hide_timer_id;

    gboolean idle_mode_enabled;

    pthread_t pw_thread;
    struct pw_main_loop *pw_loop;
    struct pw_context *pw_context;
    struct pw_core *pw_core;
    struct pw_stream *pw_stream;
    struct spa_hook stream_listener;

    fftw_plan fft_plan;
    double *fft_in;
    fftw_complex *fft_out;

    pthread_mutex_t lock;
    double magnitudes[NUM_BARS];
    double peaks[NUM_BARS];
} AppState;

// --- Forward Declarations ---
static void cleanup(GApplication *app, gpointer user_data);
static gboolean trigger_redraw(gpointer user_data);
static void update_sidebar_for_idle_mode(AppState *state);
static void show_sidebar(AppState *state);
static void hide_sidebar(AppState *state);
static GtkWidget* create_sidebar_content(AppState *state);
// Updates the exclusive zone based on the sidebar's current width.
static gboolean set_exclusive_zone_from_content(gpointer user_data);

// --- JSON Config Management ---
// This section is correct and unchanged.
static void save_idle_mode_setting(gboolean is_enabled) {
    JsonObject *root_obj = json_object_new();
    json_object_set_boolean_member(root_obj, "idle_enabled", is_enabled);
    JsonGenerator *generator = json_generator_new();
    JsonNode *root_node = json_node_new(JSON_NODE_OBJECT);
    json_node_set_object(root_node, root_obj);
    json_generator_set_root(generator, root_node);
    json_generator_set_pretty(generator, TRUE);
    gchar *json_string = json_generator_to_data(generator, NULL);
    g_file_set_contents(CONFIG_FILE_PATH, json_string, -1, NULL);
    g_free(json_string);
    json_node_free(root_node);
    g_object_unref(generator);
    json_object_unref(root_obj);
}

static gboolean load_idle_mode_setting() {
    gboolean is_enabled = TRUE;
    if (g_file_test(CONFIG_FILE_PATH, G_FILE_TEST_EXISTS)) {
        JsonParser *parser = json_parser_new();
        if (json_parser_load_from_file(parser, CONFIG_FILE_PATH, NULL)) {
            JsonNode *root_node = json_parser_get_root(parser);
            if (JSON_NODE_HOLDS_OBJECT(root_node)) {
                JsonObject *root_obj = json_node_get_object(root_node);
                if (json_object_has_member(root_obj, "idle_enabled")) {
                    is_enabled = json_object_get_boolean_member(root_obj, "idle_enabled");
                }
            }
        }
        g_object_unref(parser);
    } else {
        save_idle_mode_setting(is_enabled);
    }
    return is_enabled;
}


// --- Audio, Drawing, PipeWire ---
// These sections are correct and unchanged.
static void on_pw_process(void *data) {
    AppState *state = (AppState*)data;
    struct pw_buffer *b;
    if ((b = pw_stream_dequeue_buffer(state->pw_stream)) == NULL) return;

    struct spa_buffer *buf = b->buffer;
    if (!buf->datas[0].data) {
        pw_stream_queue_buffer(state->pw_stream, b);
        return;
    }

    float *samples = buf->datas[0].data;
    uint32_t samples_count = buf->datas[0].chunk->size / (sizeof(float) * CHANNELS);
    for (uint32_t i = 0; i < samples_count && i < SAMPLES; i++) {
        state->fft_in[i] = (samples[i * CHANNELS] + samples[i * CHANNELS + 1]) / 2.0;
    }
    for (uint32_t i = samples_count; i < SAMPLES; i++) {
        state->fft_in[i] = 0.0;
    }

    fftw_execute(state->fft_plan);

    pthread_mutex_lock(&state->lock);
    for (int i = 0; i < NUM_BARS; i++) {
        double total_mag = 0;
        int start_freq = (i == 0) ? 1 : (SAMPLES / 2) * powf((float)i / NUM_BARS, 2.0f);
        int end_freq = (SAMPLES / 2) * powf((float)(i + 1) / NUM_BARS, 2.0f);
        for (int j = start_freq; j < end_freq && j < SAMPLES / 2; j++) {
            double re = state->fft_out[j][0], im = state->fft_out[j][1];
            total_mag += sqrt(re * re + im * im);
        }

        double db = 20 * log10(total_mag > 0 ? total_mag : 1);
        double normalized_db = (db < 0 ? 0 : db) / 60.0;
        double smoothed_val = pow(normalized_db, 1.5);

        if (smoothed_val > state->magnitudes[i]) {
            state->magnitudes[i] = smoothed_val;
        } else {
            state->magnitudes[i] *= 0.85;
        }

        if (state->magnitudes[i] > state->peaks[i]) {
            state->peaks[i] = state->magnitudes[i];
        } else {
            state->peaks[i] *= 0.99;
        }
    }
    pthread_mutex_unlock(&state->lock);

    g_idle_add(trigger_redraw, state);
    pw_stream_queue_buffer(state->pw_stream, b);
}
static gboolean trigger_redraw(gpointer user_data) {
    AppState *state = (AppState*)user_data;
    if (state && state->drawing_area) gtk_widget_queue_draw(state->drawing_area);
    return G_SOURCE_REMOVE;
}
static void draw_visualizer_bars(GtkDrawingArea *a, cairo_t *cr, int w, int h, gpointer d) {
    (void)a;
    AppState *state = (AppState*)d;
    double bar_width = (double)w / NUM_BARS;
    pthread_mutex_lock(&state->lock);
    for (int i = 0; i < NUM_BARS; i++) {
        double mag = state->magnitudes[i] > 1.0 ? 1.0 : state->magnitudes[i];
        double bar_h = mag * h;
        if (bar_h < 1.0) bar_h = 0;
        cairo_pattern_t *pat = cairo_pattern_create_linear(0, h, 0, h - bar_h);
        cairo_pattern_add_color_stop_rgba(pat, 1.0, 0.4, 0.9, 0.5, 0.9);
        cairo_pattern_add_color_stop_rgba(pat, 0.0, 0.1, 0.5, 0.2, 0.8);
        cairo_set_source(cr, pat);
        cairo_rectangle(cr, i * bar_width, h - bar_h, bar_width - 2.0, bar_h);
        cairo_fill(cr);
        cairo_pattern_destroy(pat);
        double peak_mag = state->peaks[i] > 1.0 ? 1.0 : state->peaks[i];
        double peak_h = peak_mag * h;
        if (peak_h > 1.0) {
            cairo_set_source_rgba(cr, 0.9, 0.9, 1.0, 0.8);
            cairo_rectangle(cr, i * bar_width, h - peak_h, bar_width - 2.0, 2.0);
            cairo_fill(cr);
        }
    }
    pthread_mutex_unlock(&state->lock);
}
static const struct pw_stream_events stream_events = { PW_VERSION_STREAM_EVENTS, .process = on_pw_process };
static void* pipewire_thread_func(void *data) { pw_main_loop_run(((AppState*)data)->pw_loop); return NULL; }
static void setup_pipewire(AppState *state) {
    state->pw_loop = pw_main_loop_new(NULL);
    state->pw_context = pw_context_new(pw_main_loop_get_loop(state->pw_loop), NULL, 0);
    state->pw_core = pw_context_connect(state->pw_context, NULL, 0);
    state->pw_stream = pw_stream_new(
        state->pw_core, "hypr-sidebar-visualizer",
        pw_properties_new(PW_KEY_MEDIA_TYPE, "Audio", PW_KEY_MEDIA_CATEGORY, "Capture",
                          PW_KEY_MEDIA_ROLE, "Visualizer", PW_KEY_STREAM_CAPTURE_SINK, "true", NULL));
    pw_stream_add_listener(state->pw_stream, &state->stream_listener, &stream_events, state);
    uint8_t buffer[1024]; struct spa_pod_builder b; spa_pod_builder_init(&b, buffer, sizeof(buffer));
    const struct spa_pod *params[1] = { spa_format_audio_raw_build(&b, SPA_PARAM_EnumFormat, &SPA_AUDIO_INFO_RAW_INIT(.format=SPA_AUDIO_FORMAT_F32, .channels=CHANNELS, .rate=RATE)) };
    pw_stream_connect(state->pw_stream, PW_DIRECTION_INPUT, PW_ID_ANY, PW_STREAM_FLAG_AUTOCONNECT | PW_STREAM_FLAG_MAP_BUFFERS, params, 1);
    pthread_create(&state->pw_thread, NULL, pipewire_thread_func, state);
}


// --- App Logic ---

static gboolean set_exclusive_zone_from_content(gpointer user_data) {
    AppState *state = user_data;

    // Guard against being called after the window is destroyed or hidden.
    if (!state || !GTK_IS_WIDGET(state->sidebar_window) || !gtk_widget_get_visible(state->sidebar_window)) {
        return G_SOURCE_REMOVE;
    }

    // THE FIX: The instability was caused by reading the width of the GtkStack's child widget.
    // Due to the timing of GTK's layout cycle, this could return a stale width (e.g., the width
    // of the *previous* stack page), causing an incorrect exclusive zone that pushes other
    // windows too far or not far enough.
    //
    // The reliable solution is to get the allocated width of the top-level window itself.
    // The window's size is managed by GTK to fit its content. By the time this idle callback
    // executes, the window's own width (`gtk_widget_get_width`) is the most up-to-date and
    // stable value to use for setting the exclusive zone.
    int width = gtk_widget_get_width(state->sidebar_window);

    gtk_layer_set_exclusive_zone(GTK_WINDOW(state->sidebar_window), width);

    return G_SOURCE_REMOVE;
}

static void show_sidebar(AppState *state) {
    if (!state->idle_mode_enabled) return;
    if (state->hide_timer_id > 0) { g_source_remove(state->hide_timer_id); state->hide_timer_id = 0; }

    gtk_layer_set_exclusive_zone(GTK_WINDOW(state->handle_window), 0);
    gtk_widget_set_visible(state->handle_window, FALSE);

    gtk_widget_set_visible(state->sidebar_window, TRUE);
    // Defer the zone calculation until the widget is drawn and has its new size.
    g_idle_add(set_exclusive_zone_from_content, state);
}

static void hide_sidebar(AppState *state) {
    if (!state->idle_mode_enabled) return;
    
    gtk_layer_set_exclusive_zone(GTK_WINDOW(state->sidebar_window), 0);
    gtk_widget_set_visible(state->sidebar_window, FALSE);
    
    gtk_layer_set_exclusive_zone(GTK_WINDOW(state->handle_window), 30);
    gtk_widget_set_visible(state->handle_window, TRUE);
}

static gboolean hide_sidebar_timeout(gpointer d) {
    hide_sidebar((AppState*)d);
    ((AppState*)d)->hide_timer_id = 0;
    return G_SOURCE_REMOVE;
}

static void on_handle_mouse_enter(GtkEventControllerMotion *c, gdouble x, gdouble y, gpointer d) { (void)c; (void)x; (void)y; show_sidebar((AppState*)d); }
static void on_sidebar_mouse_enter(GtkEventControllerMotion *c, gdouble x, gdouble y, gpointer d) { (void)c; (void)x; (void)y; show_sidebar((AppState*)d); }

static void on_sidebar_mouse_leave(GtkEventControllerMotion *c, gpointer d) {
    (void)c;
    AppState *state = d;
    if (!state->idle_mode_enabled) return;
    const char *current_page = gtk_stack_get_visible_child_name(GTK_STACK(state->stack));
    if (g_strcmp0(current_page, "dock") == 0) {
        if (state->hide_timer_id == 0) {
            state->hide_timer_id = g_timeout_add(500, hide_sidebar_timeout, d);
        }
    }
}

static void update_sidebar_for_idle_mode(AppState *state) {
   if (state->idle_mode_enabled) {
    gtk_widget_add_css_class(state->main_content_box, "floating-style");

    double x, y;
    GdkSurface *sidebar_surface =
        gtk_native_get_surface(GTK_NATIVE(state->sidebar_window));
    GdkDevice *pointer =
        gdk_seat_get_pointer(gdk_display_get_default_seat(gdk_display_get_default()));

    gboolean pointer_inside =
        gdk_surface_get_device_position(sidebar_surface, pointer, &x, &y, NULL);

    if (!pointer_inside) {
        hide_sidebar(state);
    }

    gtk_button_set_icon_name(GTK_BUTTON(state->idle_toggle_button), "view-pin-symbolic");
    gtk_widget_set_tooltip_text(state->idle_toggle_button, "Pin Sidebar");
}
 else {
        gtk_widget_remove_css_class(state->main_content_box, "floating-style");
        
        gtk_layer_set_exclusive_zone(GTK_WINDOW(state->handle_window), 0);
        gtk_widget_set_visible(state->handle_window, FALSE);
        
        gtk_widget_set_visible(state->sidebar_window, TRUE);
        // Defer the zone calculation until the widget is drawn.
        g_idle_add(set_exclusive_zone_from_content, state);
        
        gtk_button_set_icon_name(GTK_BUTTON(state->idle_toggle_button), "document-open-symbolic");
        gtk_widget_set_tooltip_text(state->idle_toggle_button, "Unpin Sidebar (Enable Idle Mode)");
    }
}

static void on_toggle_idle_mode_clicked(GtkButton *button, gpointer user_data) {
    (void)button;
    AppState *state = user_data;
    state->idle_mode_enabled = !state->idle_mode_enabled;
    save_idle_mode_setting(state->idle_mode_enabled);
    update_sidebar_for_idle_mode(state);
}

static void on_stack_child_changed(GtkStack *stack, GParamSpec *pspec, gpointer user_data) {
    (void)stack;
    (void)pspec;
    AppState *state = user_data;
    // If the sidebar is pinned and visible, we need to update its exclusive zone.
    if (!state->idle_mode_enabled && gtk_widget_get_visible(state->sidebar_window)) {
         g_idle_add(set_exclusive_zone_from_content, state);
    }
}

// --- GTK UI Setup ---
static void load_css(void) { GtkCssProvider *p = gtk_css_provider_new(); gtk_css_provider_load_from_path(p, "../src/style.css"); gtk_style_context_add_provider_for_display(gdk_display_get_default(), GTK_STYLE_PROVIDER(p), 900); g_object_unref(p); }

static GtkWidget* create_sidebar_content(AppState *state) {
    state->main_content_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
    gtk_widget_add_css_class(state->main_content_box, "main-content-box");

    state->stack = gtk_stack_new();
    gtk_stack_set_transition_type(GTK_STACK(state->stack), GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT_RIGHT);
    gtk_stack_set_transition_duration(GTK_STACK(state->stack), 350);

    g_signal_connect(state->stack, "notify::visible-child", G_CALLBACK(on_stack_child_changed), state);

    GtkWidget *dock_view = create_dock_view(GTK_STACK(state->stack));
    GtkWidget *cc_view = create_control_center_view(state->app, GTK_STACK(state->stack));

    state->idle_toggle_button = gtk_button_new_from_icon_name("view-pin-symbolic");
    gtk_widget_set_vexpand(state->idle_toggle_button, FALSE);
    g_signal_connect(state->idle_toggle_button, "clicked", G_CALLBACK(on_toggle_idle_mode_clicked), state);

    if (GTK_IS_BOX(cc_view)) {
        gtk_box_append(GTK_BOX(cc_view), gtk_separator_new(GTK_ORIENTATION_HORIZONTAL));
        gtk_box_append(GTK_BOX(cc_view), state->idle_toggle_button);
    }
    
    gtk_stack_add_named(GTK_STACK(state->stack), dock_view, "dock");
    gtk_stack_add_named(GTK_STACK(state->stack), cc_view, "controls");

    gtk_box_append(GTK_BOX(state->main_content_box), state->stack);
    
    return state->main_content_box;
}

// --- only the 'activate' function is changed ---

static void activate(GtkApplication *app, gpointer user_data) {
    (void)user_data; load_css(); AppState *state = g_new0(AppState, 1);
    state->app = app;
    g_object_set_data_full(G_OBJECT(app), "app-state", state, (GDestroyNotify)g_free);
    g_signal_connect(app, "shutdown", G_CALLBACK(cleanup), state);

    state->idle_mode_enabled = load_idle_mode_setting();

    state->fft_in = fftw_alloc_real(SAMPLES);
    state->fft_out = fftw_alloc_complex(SAMPLES/2+1);
    state->fft_plan = fftw_plan_dft_r2c_1d(SAMPLES, state->fft_in, state->fft_out, FFTW_ESTIMATE);
    pthread_mutex_init(&state->lock, NULL);

    state->sidebar_window = gtk_application_window_new(app);
    gtk_layer_init_for_window(GTK_WINDOW(state->sidebar_window));
    gtk_layer_set_layer(GTK_WINDOW(state->sidebar_window), GTK_LAYER_SHELL_LAYER_TOP);
    gtk_layer_set_anchor(GTK_WINDOW(state->sidebar_window), GTK_LAYER_SHELL_EDGE_LEFT, TRUE);

    // THE FIX: Use the correct function 'gtk_layer_set_keyboard_mode'.
    // Setting the mode to GTK_LAYER_SHELL_KEYBOARD_MODE_ON_DEMAND tells the
    // compositor that this surface can receive keyboard focus when requested
    // (e.g., when a user clicks a GtkDropDown). This is the key to allowing
    // popups to draw outside the main window's boundaries without being clipped.
    gtk_layer_set_keyboard_mode(GTK_WINDOW(state->sidebar_window), GTK_LAYER_SHELL_KEYBOARD_MODE_ON_DEMAND);

    // The content, including the stack, is created here.
    gtk_window_set_child(GTK_WINDOW(state->sidebar_window), create_sidebar_content(state));

    GtkEventController *sm = gtk_event_controller_motion_new();
    g_signal_connect(sm, "enter", G_CALLBACK(on_sidebar_mouse_enter), state);
    g_signal_connect(sm, "leave", G_CALLBACK(on_sidebar_mouse_leave), state);
    gtk_widget_add_controller(state->sidebar_window, sm);

    state->handle_window = gtk_application_window_new(app);
    gtk_widget_add_css_class(state->handle_window, "handle-window");
    gtk_layer_init_for_window(GTK_WINDOW(state->handle_window));
    gtk_layer_set_layer(GTK_WINDOW(state->handle_window), GTK_LAYER_SHELL_LAYER_TOP);
    gtk_layer_set_anchor(GTK_WINDOW(state->handle_window), GTK_LAYER_SHELL_EDGE_LEFT, TRUE);
    gtk_window_set_default_size(GTK_WINDOW(state->handle_window), 30, -1);
    gtk_layer_set_exclusive_zone(GTK_WINDOW(state->handle_window), 30);
    state->drawing_area = gtk_drawing_area_new();
    gtk_drawing_area_set_draw_func(GTK_DRAWING_AREA(state->drawing_area), draw_visualizer_bars, state, NULL);
    gtk_window_set_child(GTK_WINDOW(state->handle_window), state->drawing_area);
    GtkEventController *hm = gtk_event_controller_motion_new();
    g_signal_connect(hm, "enter", G_CALLBACK(on_handle_mouse_enter), state);
    gtk_widget_add_controller(state->handle_window, hm);

    update_sidebar_for_idle_mode(state);
    setup_pipewire(state);
}

// --- Main and Cleanup ---
static void cleanup(GApplication *app, gpointer user_data) {
    (void)app; AppState *state = (AppState*)user_data;
    if (state->pw_loop) pw_main_loop_quit(state->pw_loop);
    if (state->pw_thread) pthread_join(state->pw_thread, NULL);
    if (state->pw_stream) pw_stream_destroy(state->pw_stream);
    if (state->pw_core) pw_core_disconnect(state->pw_core);
    if (state->pw_context) pw_context_destroy(state->pw_context);
    if (state->pw_loop) pw_main_loop_destroy(state->pw_loop);
    if (state->fft_plan) fftw_destroy_plan(state->fft_plan);
    if (state->fft_in) fftw_free(state->fft_in);
    if (state->fft_out) fftw_free(state->fft_out);
    pthread_mutex_destroy(&state->lock);
}

int main(int argc, char **argv) {
    pw_init(&argc, &argv); GtkApplication *app = gtk_application_new("com.spn4x.hyprsidebar", G_APPLICATION_DEFAULT_FLAGS);
    g_signal_connect(app, "activate", G_CALLBACK(activate), NULL);
    int status = g_application_run(G_APPLICATION(app), argc, argv);
    g_object_unref(app); pw_deinit(); return status;
}===== src/control_center.h =====
#ifndef CONTROL_CENTER_H
#define CONTROL_CENTER_H

#include <gtk/gtk.h>

// This struct is now defined in the header so it's visible to all files.
typedef struct {
    GtkWidget *volume_slider;
    GtkWidget *output_selector;
} ControlWidgets;

// This is the only function from control_center.c that other files need.
GtkWidget* create_control_center_view(GtkApplication *app, GtkStack *stack);

#endif===== src/utils.c =====
#include "utils.h"
#include <stdio.h>

// ++ MODIFIED: The result struct now holds both stdout and stderr ++
typedef struct {
    gchar *stdout_buffer;
    gchar *stderr_buffer;
} CommandResult;

typedef struct {
    GTask *task;
    char *command;
} CommandData;

static void on_command_finished(GObject *source_object, GAsyncResult *res, gpointer user_data) {
    CommandData *data = (CommandData*)user_data;
    GSubprocess *proc = G_SUBPROCESS(source_object);
    CommandResult *result = g_new0(CommandResult, 1);
    GError *error = NULL;

    g_subprocess_communicate_utf8_finish(proc, res, &result->stdout_buffer, &result->stderr_buffer, &error);
    
    if (error) {
        g_warning("COMMAND FAILED: \"%s\"\n--- ERROR ---\n%s\n-------------\n", data->command, error->message);
        g_task_return_error(data->task, error);
        g_free(result->stdout_buffer);
        g_free(result->stderr_buffer);
        g_free(result);
    } else {
        // Log both stdout and stderr for debugging
        g_print("COMMAND SUCCEEDED: \"%s\"\n--- STDOUT ---\n%s\n--- STDERR ---\n%s\n--------------\n", 
                data->command, 
                result->stdout_buffer ? result->stdout_buffer : "[No output]",
                result->stderr_buffer ? result->stderr_buffer : "[No error output]");
        g_task_return_pointer(data->task, result, (GDestroyNotify)g_free);
    }
    
    g_object_unref(data->task);
    g_free(data->command);
    g_free(data);
}

void execute_command_async(const char* command, GAsyncReadyCallback callback, gpointer user_data) {
    GError *error = NULL;
    gchar **argv = NULL;
    if (!g_shell_parse_argv(command, NULL, &argv, &error)) {
        g_warning("Error parsing command: %s", error->message);
        g_error_free(error);
        return;
    }

    GSubprocess *proc = g_subprocess_newv((const gchar * const *)argv,
                                          G_SUBPROCESS_FLAGS_STDOUT_PIPE | G_SUBPROCESS_FLAGS_STDERR_PIPE,
                                          &error);
    g_strfreev(argv);
    if (error) {
        g_warning("Error creating subprocess: %s", error->message);
        g_error_free(error);
        return;
    }
    
    g_print("EXECUTING COMMAND: \"%s\"\n", command);
    
    CommandData *data = g_new(CommandData, 1);
    data->task = g_task_new(proc, NULL, callback, user_data);
    data->command = g_strdup(command);
    
    g_subprocess_communicate_utf8_async(proc, NULL, NULL, on_command_finished, data);
}

// ++ MODIFIED: These helpers now return the specific streams ++
const char* get_command_stdout(GAsyncResult *res) {
    GError *error = NULL;
    CommandResult *result = g_task_propagate_pointer(G_TASK(res), &error);
    if (error || !result) {
        if (error) g_error_free(error);
        return NULL;
    }
    return result->stdout_buffer;
}

const char* get_command_stderr(GAsyncResult *res) {
    GError *error = NULL;
    CommandResult *result = g_task_propagate_pointer(G_TASK(res), &error);
    if (error || !result) {
        if (error) g_error_free(error);
        return NULL;
    }
    return result->stderr_buffer;
}